using System.Collections;
using System.Collections.Generic;
using UnityEngine;


public class MapGenerator : MonoBehaviour 
{
	public GameObject[] mapTiles;         // array for holding map tiles
	public int mapWidth = 10;             // map width   
	public int mapHeight = 10;            // map height - set from JSON
	public int numberOfHouses = 96;       // number of houses - also comes from JSON
	public int mapRenderWidth = 3;        // visible part of the map width
	public int mapRenderHeight = 3;       // visible part of the map height

	private float tileSizeMod = 0.5f;     // tile size modifier - used for zoom in, zoom out

	private int[,] mapMemory;             // two dimensional array that holds map. Each int value represents one tile. 0 - house, 1- grass, 2 - sand, etc...
	public int cameraPositionX;          // camera position X
	public int cameraPositionY;          // camera position Y - used to 'lock' part of map that we are looking at

	//private Vector2 startPosition = new Vector2( 0, 0 );

	/*
	void Awake ()
	{
		print( "awake" );
	}
	*/

	void Start () 
	{
		// resize all tiles, acording to tileSizemod
		for( int i = 0; i < mapTiles.Length; i++ )
		{
			mapTiles[i].transform.localScale = new Vector3( 1.0f * tileSizeMod, 1.0f * tileSizeMod, 1 );
		}

		//cameraPositionX = Random.Range(20, 100);  // starting camera position
		//cameraPositionY = Random.Range(20, 100);  // let it be somewhere lower left

		//cameraPositionX = 30;
		//cameraPositionY = 30;

		//GenerateMap();    // make map in memory
		GenerateMap_Perlin();    // make map in memory

		DrawMap();        // draw map on screen

		DisplayInfo.di.UpdateUI( "Position: ( " + cameraPositionX + ", " + cameraPositionY + " )", "Number of houses: " + numberOfHouses ); // display info about current position

		MiniMap.mp.DrawMinimap( mapMemory, mapWidth, mapHeight );                         // draw minimap
		//MiniMap.mp.DrawSquare( cameraPositionX, cameraPositionY, 20 );   // draw square ( our initial position )

		MiniMap.mp.ShowMiniMap( false );
	}

	void Update () 
	{
		// Do mouse scroll
		// 1. Delete / Kill all tiles on part we are looking at
		// 2. Resize all tiles
		// 3. Draw map
		if( Input.mouseScrollDelta.y > 0 )
		{			
			KillTiles();                     

			tileSizeMod += 0.05f;
			if( tileSizeMod > 2 )
			{
				tileSizeMod = 2;
			}
				
			if( tileSizeMod > 0.9 )
			{
				mapRenderHeight = 16;
				mapRenderWidth = 8;
			}

			for( int i = 0; i < mapTiles.Length; i++ )
			{
				mapTiles[i].transform.localScale = new Vector3( 1.0f * tileSizeMod, 1.0f * tileSizeMod, 1 );
			}
			DrawMap();
		}
		if( Input.mouseScrollDelta.y < 0 )
		{
			KillTiles();

			tileSizeMod -= 0.05f;
			if( tileSizeMod < 0.25f )
			{
				tileSizeMod = 0.25f;
			}


			if( tileSizeMod < 0.9 )
			{
				mapRenderHeight = 30;
				mapRenderWidth = 25;
			}


			for( int i = 0; i < mapTiles.Length; i++ )
			{
				mapTiles[i].transform.localScale = new Vector3( 1.0f * tileSizeMod, 1.0f * tileSizeMod, 1 );
			}
			DrawMap();
		}
		// Mouse scroll done.
			

		// Do keyboard and mouse movement.
		// Map moves when user presses arrows or hit's one of the edges with mouse.
		if( Input.GetKey( KeyCode.LeftArrow ) || Input.mousePosition.x == 0 )
		{
			if( cameraPositionX > 10 )
			{
				KillTiles();
				cameraPositionX--;
				DrawMap();
			}
		}
		if( Input.GetKey( KeyCode.RightArrow ) || Input.mousePosition.x == Screen.width - 1 )
		{
			if( cameraPositionX < mapWidth - 10 )
			{
				KillTiles();			
				cameraPositionX++;
				DrawMap();
			}
		}
		if( Input.GetKey( KeyCode.UpArrow ) || Input.mousePosition.y == Screen.height - 1)
		{
			if( cameraPositionY < mapHeight - 5 )
			{
				KillTiles();
				cameraPositionY++;
				DrawMap();
			}
		}
		if( Input.GetKey( KeyCode.DownArrow ) || Input.mousePosition.y == 0 )
		{
			if( cameraPositionY > 5 )
			{			
				KillTiles();
				cameraPositionY--;
				DrawMap();
			}
		}
		// Keyboard done.

		if( Input.GetKeyDown( KeyCode.M ) )
		{
			if( MiniMap.mp.IsMiniMapOnScreen() == false )
				MiniMap.mp.ShowMiniMap( true );
			else
				MiniMap.mp.ShowMiniMap( false );
		}
		// Do more keyboard, exit...
		if( Input.GetKeyDown( KeyCode.Escape ) )
		{
			Application.Quit();
		}
	}


	void GenerateMap_Perlin()
	{
		mapMemory = new int[mapWidth, mapHeight];

		for( int i = 0; i < mapWidth; i++ )
		{
			for( int j = 0; j < mapHeight; j++ )
			{
				// Add water and sand.
				// Water and sand are generated with perlin noise
				float z = FindTileType(i,j);
				if( z < 0.25f )               // water
					mapMemory[i, j] = 6;
				else
				if( z > 0.25 && z < 0.30f )
					mapMemory[i, j] = 2;      // sand
				else
					mapMemory[i, j] = 1;


				// Add forests.
				// Forest are also generated by perlin.
				float x = FindTileTypeFP( i, j );
				if( x < 0.35f && mapMemory[i, j] == 1 )               // voda
				{
					mapMemory[i, j] = Random.Range(4,6);
				}

				// Add some totally random trees. Makes map look better.
				// Draw trees only if tile is grass. We don't want trees on water or sand
				int y = FindTileTypeF(i,j);
				if( y < 5 && mapMemory[i, j] == 1 )              
					mapMemory[i, j] = 4;
				if( ( y > 5 && y < 10 ) && mapMemory[i, j] == 1 )
					mapMemory[i, j] = 5;
			}
		}

		// and finally, add houses...
		AddHouses ( numberOfHouses );
	}

	/// <summary>
	/// Ads houses on map. It simple random method...
	/// </summary>
	/// <param name="_number">Number.</param>
	void AddHouses( int _number )
	{
		int _counter = 0;

		while( _counter < _number )
		{
			int xTile = Random.Range( 0, mapWidth );
			int yTile = Random.Range( 0, mapHeight );			

			// check what's on current tile.
			// Houses can be built on grass ( 1 ) , or forest tiles ( 4,5 )
			if( mapMemory[xTile, yTile] == 1 || 
				mapMemory[xTile, yTile] == 4 ||
				mapMemory[xTile, yTile] == 5 )
			{				
				
				int v = Random.Range( 0, 101 );

				if( v < 30 )
					mapMemory[xTile, yTile] = 3; // we want 30% of storages
				else
					mapMemory[xTile, yTile] = 0; // and 70% of houses
				_counter++;
			}
		}

	}

	/// <summary>
	/// Generate float based on Perlin noise
	/// </summary>
	/// <returns>The tile type.</returns>
	/// <param name="x">The x coordinate.</param>
	/// <param name="y">The y coordinate.</param>
	float FindTileType( int x, int y )
	{
		float _x = (float)x / mapWidth * 18;
		float _y = (float)y / mapHeight * 18;

		float v = Mathf.PerlinNoise( _x, _y );
		//print ( v );
		return v; 
	}

	/// <summary>
	/// Returns random number between 0 - 100. This is used for placing random trees
	/// </summary>
	/// <returns>The tile type f.</returns>
	/// <param name="x">The x coordinate.</param>
	/// <param name="y">The y coordinate.</param>
	int FindTileTypeF( int x, int y )
	{
		int v = Random.Range( 0, 100 );
		return v;
	}

	/// <summary>
	/// Returns perlin noise float number. To make things more interesting, x and y are swaped.
	/// </summary>
	/// <returns>The tile type F.</returns>
	/// <param name="x">The x coordinate.</param>
	/// <param name="y">The y coordinate.</param>
	float FindTileTypeFP( int x, int y )
	{
		float _x = (float)x / mapWidth * 30;
		float _y = (float)y / mapHeight * 30;

		float v = Mathf.PerlinNoise( _y , _x );
		//print ( v );
		return v; 
	}

	/// <summary>
	/// Generates map in memory
	/// </summary>
	void GenerateMap()
	{
		mapMemory = new int[mapWidth, mapHeight];

		for( int i = 0; i < mapWidth; i++ )
		{
			for( int j = 0; j < mapHeight; j++ )
			{
				mapMemory[i, j] = 1;
			}
		}

		// nacrtaj sumicu
		int numberOfTrees;
		int deviationX;
		int deviationY;
		Vector2 startPosition;

		for( int i = 0; i < 500; i++ )
		{
			startPosition = new Vector2( Random.Range(0, mapWidth), Random.Range(0, mapHeight) );
			numberOfTrees = 100;
			deviationX = 10;
			deviationY = 10;

			for( int j = 0; j < numberOfTrees; j++ )
			{
				int posX = (int)startPosition.x;
				int posY = (int)startPosition.y;

				//print( posX );
				Vector2 num = Random.insideUnitCircle;

				posX = (int)(posX - num.x * deviationX);
				posY = (int)(posY - num.y * deviationY);

				//print( posX + " " + posY );

				if( posX >= mapWidth )
					posX = mapWidth - 2;
				if( posY >= mapHeight )
					posY = mapHeight - 2;
				if( posX < 0 )
					posX = 0;
				if( posY < 0 )
					posY = 0;				

				mapMemory[posX, posY] = Random.Range(4,6);
			}
		}

		// nacrtaj kucice
		for( int i = 0; i < numberOfHouses * 3; i++ )
		{
			//Vector2 position = new Vector2( Random.Range(0, mapWidth), Random.Range(0, mapHeight) );
			int v = Random.Range(0,2);
			if( v == 0 )
				mapMemory[Random.Range( 0, mapWidth ), Random.Range( 0, mapHeight )] = 0;
			if( v == 1 )
				mapMemory[Random.Range( 0, mapWidth ), Random.Range( 0, mapHeight )] = 3;			
		}

		// nacrtaj vodicu
		for( int i = 0; i < 60; i++ )
		{
			int posX = 30;
			int posY = 30;			

			Vector2 num = Random.insideUnitCircle;

			posX = (int)(posX - num.x * 5);
			posY = (int)(posY - num.y * 5);

			//print( posX + " " + posY );

			if( posX >= mapWidth )
				posX = mapWidth - 2;
			if( posY >= mapHeight )
				posY = mapHeight - 2;
			if( posX < 0 )
				posX = 0;
			if( posY < 0 )
				posY = 0;				

			mapMemory[posX, posY] = 6;
		}
	}

	void KillTiles()
	{
		GameObject[] tiles = GameObject.FindGameObjectsWithTag("mapTile");
		foreach(GameObject tile in tiles)
			GameObject.Destroy(tile);		
	}

	public void KillObject(int x, int y)
	{
		KillTiles();	
		mapMemory[x, y] = 5;
		numberOfHouses--;

		DrawMap();

		MiniMap.mp.ClearTex();
		MiniMap.mp.DrawMinimap( mapMemory, mapWidth, mapHeight ); 
		DisplayInfo.di.ShowTileInfo( false );
	}

	/// <summary>
	/// Draws the map on screen.
	/// </summary>
	void DrawMap ()
	{
		GameObject _go;
		GameObject _source;

		for( int i = -mapRenderWidth; i < mapRenderWidth; i++ )
		{
			for( int j = -mapRenderHeight; j < mapRenderHeight; j++ )
			{
				

				float tileWidth = mapTiles[1].GetComponent<BoxCollider2D>().size.x * tileSizeMod;
				int tileCode = 0;
				try
				{
					
					tileCode = mapMemory[cameraPositionX + i, cameraPositionY + j];
					_go = Instantiate( mapTiles[tileCode], new Vector2( 0 + tileWidth * i, 0 + tileWidth * j ), Quaternion.identity );
					_go.tag = "mapTile";
					_go.name = "generatedMapTile";

					_go.GetComponent<TileScript>().SetPosition ( cameraPositionX + i, cameraPositionY + j );

					//print ( i + mapRenderWidth );
					// za jso, na osnovu tileCodea pokupi podatke iz json parsera
					if ( tileCode == 0 )
					{
						_go.GetComponent<TileScript>().Name = "Barrack";
						_go.GetComponent<TileScript>().Type = "house1";
						_go.GetComponent<TileScript>().Level = 2;
					}	
					if ( tileCode == 1 )
					{
						_go.GetComponent<TileScript>().Name = "Empty Tile";
						_go.GetComponent<TileScript>().Type = "grass";
						_go.GetComponent<TileScript>().Level = 0;
					}
					if ( tileCode == 2 )
					{
						_go.GetComponent<TileScript>().Name = "Empty Tile";
						_go.GetComponent<TileScript>().Type = "sand";
						_go.GetComponent<TileScript>().Level = 0;
					}
					if ( tileCode == 3 )
					{
						_go.GetComponent<TileScript>().Name = "Storage";
						_go.GetComponent<TileScript>().Type = "house2";
						_go.GetComponent<TileScript>().Level = 1;
					}
					if ( tileCode == 4 )
					{
						_go.GetComponent<TileScript>().Name = "Empty Tile";
						_go.GetComponent<TileScript>().Type = "trees1";
						_go.GetComponent<TileScript>().Level = 0;
					}
					if ( tileCode == 5 )
					{
						_go.GetComponent<TileScript>().Name = "Empty Tile";
						_go.GetComponent<TileScript>().Type = "trees2";
						_go.GetComponent<TileScript>().Level = 0;
					}
					if ( tileCode == 6 )
					{
						_go.GetComponent<TileScript>().Name = "Lake";
						_go.GetComponent<TileScript>().Type = "water";
						_go.GetComponent<TileScript>().Level = 0;
					}
					
				}
				catch
				{
					tileCode = 5; // ili 7????
					_go = Instantiate( mapTiles[tileCode], new Vector2( 0 + tileWidth * i, 0 + tileWidth * j ), Quaternion.identity );
					_go.tag = "mapTile";
				}
			}
		}
			
		DisplayInfo.di.UpdateUI( "Position: ( " + cameraPositionX + ", " + cameraPositionY + " )", "Number of houses: " + numberOfHouses );

	}
}
